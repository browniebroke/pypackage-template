{#
  MACRO: format the breaking changes description by:
  - Capitalizing the description
  - Adding an optional scope prefix
#}{%  macro format_breaking_changes_description(commit)
%}{%    set ns = namespace(full_description="")
%}{#
#}{%    if commit.error is undefined
%}{%      for paragraph in commit.breaking_descriptions
%}{%        if paragraph | trim | length > 0
%}{%          set paragraph_text = [
                paragraph.split(" ", maxsplit=1)[0] | capitalize,
                paragraph.split(" ", maxsplit=1)[1]
              ] | join(" ") | trim | safe
%}{%          set ns.full_description = [ns.full_description, paragraph_text] | join("\n\n")
%}{%        endif
%}{%      endfor
%}{#
#}{%      set ns.full_description = ns.full_description | trim
%}{#
#}{%      if commit.scope
%}{%        set ns.full_description = "**%s**: %s" | format(commit.scope, ns.full_description)
%}{%      endif
%}{%    endif
%}{#
#}{{    ns.full_description
}}{%  endmacro
%}


{#
  MACRO: apply smart ordering of commits objects based on alphabetized breaking changes and then scopes
  - Commits are sorted based on the commit type and the commit message
  - Commits are grouped by the commit type
  - parameter: ns (namespace) object with a commits list
  - returns None but modifies the ns.commits list in place
#}{%  macro apply_alphabetical_ordering_by_brk_descriptions(ns)
%}{%    set ordered_commits = []
%}{#
   #    # Eliminate any ParseError commits from input set
#}{%    set filtered_commits = ns.commits | rejectattr("error", "defined") | list
%}{#
   #    # grab all commits with no scope and sort alphabetically by the first line of the commit message
#}{%    for commit in filtered_commits | rejectattr("scope") | sort(attribute='breaking_descriptions.0')
%}{{      ordered_commits.append(commit) | default("", true)
}}{%     endfor
%}{#
   #    # grab all commits with a scope and sort alphabetically by the scope and then the first line of the commit message
#}{%    for commit in filtered_commits | selectattr("scope") | sort(attribute='scope,breaking_descriptions.0')
%}{{      ordered_commits.append(commit) | default("", true)
}}{%    endfor
%}{#
   #    # Return the ordered commits
#}{%    set ns.commits = ordered_commits
%}{%  endmacro
%}


{#
  MACRO: Retrieve the PR identifier based on the HVCS type
#}{%  macro get_pr_identifier(hvcs_type)
%}{#    # Determine the PR identifier based on the HVCS type
#}{%    if hvcs_type == "gitlab"
%}{%      set pr_identifier = "!"
%}{%    elif hvcs_type in ["bitbucket", "gitea", "github"]
%}{%      set pr_identifier = "#"
%}{%    else
%}{%      set pr_identifier = ""
%}{%    endif
%}{{    pr_identifier | default("", true)
}}{%  endmacro
%}


{#
  MACRO: commit message links or PR/MR links of commit
#}{%  macro commit_msg_links(commit, hvcs_type)
%}{%    if commit.error is undefined
%}{%      set commit_hash_link = "[`%s`](%s)" | format(
            commit.short_hash, commit.hexsha | commit_hash_url
          )
%}{#
#}{%      set summary_line = commit.descriptions[0] | safe
%}{%      set summary_line = [
            summary_line.split(" ", maxsplit=1)[0] | capitalize,
            summary_line.split(" ", maxsplit=1)[1]
          ] | join(" ")
%}{#
   #      # Determine the PR identifier based on the HVCS type
#}{%      set pr_identifier = get_pr_identifier(hvcs_type) | default("", true)
%}{#
#}{%      if pr_identifier != "" and summary_line.split("(" ~ pr_identifier) | length > 1
%}{#        # Replace PR references with a link to the PR
#}{%        set pr_num = summary_line.split("(" ~ pr_identifier, maxsplit=1)[1].split(")")[0]
%}{%        set pr_link = "[%s](%s)" | format(pr_identifier ~ pr_num, pr_num | pull_request_url)
%}{%        set replacement = "(%s, %s)" | format(pr_link, commit_hash_link)
%}{%        set search_text = "(%s)" | format(pr_identifier ~ pr_num)
%}{%        set summary_line = summary_line | replace(search_text, replacement)
%}{#
          # DEFAULT: No PR identifier found, so just append commit hash as url to the commit summary_line
#}{%      else
%}{%        set summary_line = "%s (%s)" | format(summary_line, commit_hash_link)
%}{%      endif
%}{#
          # Return the modified summary_line
#}{{      summary_line
}}{%    endif
%}{%  endmacro
%}


{#
  MACRO: format the first line of the commit message with optional scope
  - PR/MR links are added if found in the first line description
  - commit hash links are always added
#}{%  macro format_commit_summary_line(commit, hvcs_type)
%}{%    if commit.error is undefined
%}{%      set summary_line = commit_msg_links(commit, hvcs_type)
%}{%      if commit.scope
%}{%        set summary_line = "**%s**: %s" | format(commit.scope, summary_line)
%}{%      endif
%}{{      summary_line
}}{%    endif
%}{%  endmacro
%}


{#
  MACRO: apply smart ordering of commits objects based on alphabetized summaries and then scopes
  - Commits are sorted based on the commit type and the commit message
  - Commits are grouped by the commit type
  - parameter: ns (namespace) object with a commits list
  - returns None but modifies the ns.commits list in place
#}{%  macro apply_alphabetical_ordering_by_descriptions(ns)
%}{%    set ordered_commits = []
%}{#
   #    # Eliminate any ParseError commits from input set
#}{%    set filtered_commits = ns.commits | rejectattr("error", "defined") | list
%}{#
   #    # grab all commits with no scope and sort alphabetically by the first line of the commit message
#}{%    for commit in filtered_commits | rejectattr("scope") | sort(attribute='descriptions.0')
%}{{      ordered_commits.append(commit) | default("", true)
}}{%     endfor
%}{#
   #    # grab all commits with a scope and sort alphabetically by the scope and then the first line of the commit message
#}{%    for commit in filtered_commits | selectattr("scope") | sort(attribute='scope,descriptions.0')
%}{{      ordered_commits.append(commit) | default("", true)
}}{%    endfor
%}{#
   #    # Return the ordered commits
#}{%    set ns.commits = ordered_commits
%}{%  endmacro
%}
